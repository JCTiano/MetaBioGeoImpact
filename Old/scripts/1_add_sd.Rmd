---
title: "Add standard deviations"
author: "Emil De Borger"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

# Intro

We add missing standard deviations 

```{r read data}

# Load dataset
df <- read.csv("../dataset/trawling_meta-analysis_grouped11_10_2023.csv", sep = ";")
colnames(df) <- make.names(colnames(df), unique=TRUE)

# Make standard deviations positive
df[,c(6, 45, 50, 55)] <- abs(df[,c(6, 45, 50, 55)]) # make all SD positive.

# new column for use in analysis or not.
df$useadv <- NA
df$sdadded <- NA
df$toremoveAC <- NA
df$toremoveAI <- NA
df$toremoveBI <- NA
df$toremoveBC <- NA

# Make new columns for effect size calculations
df$response1=NA
df$SD1=NA
df$n1=NA

df$response2=NA
df$SD2=NA
df$n2=NA

# For reviewer
df$sdnoteAC=NA
df$sdnoteAI=NA
df$sdnoteBI=NA
df$sdnoteBC=NA

```

## Fill in missing sd

```{r add missing standard deviations}

#### Adding in missing SD's.
## Fill in sd function.
# make a not in function for later by negating %in%. !%in% does not work.

`%notin%` <- Negate(`%in%`) 

# Function is missSD and requires columns of the specific treatment to be filled in.
# I don't think i can use all treatments together to calculate missing sd.
## Debugging
dff = newdf
mean = 3
sd = 6
nc = 7
toremove = 59
sdnote = 69
i <- "Chl-a"

infolist <- NULL

missingSD <- function(dff, mean, sd, nc, toremove, sdnote){
  
  for (i in unique(dff[["Response.variable"]])){
    
    subset <- dff[dff["Response.variable"] == i,] # Select subset of variable i
    tofill <- which(is.na(subset[,sd]) & !is.na(subset[,mean]))  # which rows with SD's need to be filled?
    filled <- which(!is.na(subset[,sd]) & !is.na(subset[,mean])) # which rows are filled.
    
    infolist[[i]]$ntotal <- length(subset[,mean])
    
    # If there are more sd's to be estimated than known sd's, they should all be removed.
    if(length(tofill) > length(filled)){
      
      dff[toremove][as.numeric(rownames(subset))[tofill],] <- "YES"
      dff[sdnote][as.numeric(rownames(subset))[tofill],] <- "more missing SD than known SD"
    
    # If all sd's should be estimated, they should all be removed.
    }else if (length(tofill) == length(subset[sd])){
      
      dff[toremove][as.numeric(rownames(subset))[tofill],] <- "YES"
      dff[sdnote][as.numeric(rownames(subset))[tofill],] <- "All SD missing"
      
    # If no sd's need to be filled, do nothing.
    }else if (length(tofill) == 0){
      
      b <- 1
      dff[sdnote][as.numeric(rownames(subset))[tofill],] <- "All SD present"
      
    # If some need to be filled, it depends whether n is 1 or n > 1.
    }else{
      print("Some need to be filled")
      for(j in tofill){
        
        dff$sdadded[as.numeric(rownames(subset)[j])] <- 1

        if(subset[j,nc] == 1){             # If n = 1 then the sd is just 0.
          
          print("n = 1")
          # Add highest found sd.
          subset[j, sd] <- max(subset[sd], na.rm = TRUE)
          subset[j, sdnote] <- "n = 1 so max SD added"
          
        } else{
          
          # summed means -> sum all means of which an sd is known in subset.
          smean <- sum(na.omit(subset[mean][-tofill]))
          
          # summed sd -> sum all known sds in subset.
          ssd   <- sum(na.omit(subset[sd][-tofill]))
          
          # Calc the new sd with formula from book and replace sd.
          newsd     <- subset[j, mean] * ssd/smean
          subset[j, sd] <- abs(newsd)
          subset[j, sdnote] <- "averaged existing SD added"
          
        }     

      }
      
      dff[sd][as.numeric(rownames(subset)),] <- subset[[sd]]
      dff[sdnote][as.numeric(rownames(subset)),] <- subset[[sdnote]]
    }
  }
  return(dff)
}


newdf <- df
newdf <- missingSD(dff = newdf, mean = 3 , sd = 6 , nc = 7 , toremove = 59, sdnote = 69) # after control
newdf <- missingSD(dff = newdf, mean = 42, sd = 45, nc = 46, toremove = 60, sdnote = 70) # after impact
newdf <- missingSD(dff = newdf, mean = 47, sd = 50, nc = 51, toremove = 61, sdnote = 71) # before impact
newdf <- missingSD(dff = newdf, mean = 52, sd = 55, nc = 56, toremove = 62, sdnote = 72) # before control

```

```{r}

# Now we have a dataset where some SD's have been filled in, but others have to remain blank, and cannot be used for advanced meta-analysis.
save(newdf, file = "../dataset/dataset.rdata")     

```

## Old

```{r label, options}

# missSD <- function(dff, mean, sd, nc) {
#   tofill <- which(is.na(dff[,sd]) & !is.na(dff[,mean])) # Rows where I set sd to 9999 (mean reported but no sd).
#     for(i in tofill){
#         if(dff[i,nc] == 1){             # If n = 1 then the sd is just 0.
#           dff[i, sd] <- 0        
#         } else{
#           var      <- dff$`Response.variable`[i] # select variable of row.  
#           st       <- dff$`Harmonized_study.type`[i] # select study type of row.
#           
#           # Use variable and study type to take a subset of similar measurements of which sd can be computed.
#           subset   <- subset(dff[,c(1,14,mean, sd, nc)], dff$`Response.variable` == var & dff$`Harmonized_study.type` == st)
#           
#           # summed means -> sum all means of which an sd is known in subset.
#           smean <- sum(na.omit(subset[rownames(subset) %notin% tofill, 3]))
#           
#           # summed sd -> sum all known sds in subset.
#           ssd   <- sum(na.omit(subset[rownames(subset) %notin% tofill, 4]))
#           
#           # Calc the new sd with formula from book and replace sd.
#           newsd     <- dff[i, mean] * ssd/smean
#           dff[i, sd] <- abs(newsd)
#         }
#     }
#   return(dff[,sd])
# }

```

```{r label, options}

chl <- c(3.502333333,
6.26,
4.849666667,
4.5055,
5.081333333,
7.4575,
4.675,
8.5285
)

diepte <- c(-554,
-416,
-403,
-400,
-382,
-311,
-289,
-220
)

lm(chl~diepte)


```