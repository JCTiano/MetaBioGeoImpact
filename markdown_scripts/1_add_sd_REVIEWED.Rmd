---
title: "1.5_add_sd, for REVIEW"
author: "Emil De Borger"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading and naming

This part adds necessary columns to be able to run calculations and add annotations later.

```{r}

# Load dataset
df <- read.csv("../dataset/trawling_meta-analysis_grouped11_10_2023.csv", sep = ";")
colnames(df) <- make.names(colnames(df), unique=TRUE)

# Make standard deviations positive
df[,c(6, 45, 50, 55)] <- abs(df[,c(6, 45, 50, 55)]) # make all SD positive.

# new column for use in analysis or not.
df$useadv <- NA
df$sdadded <- NA

# Make new columns for effect size calculations
df$response1=NA
df$SD1=NA
df$n1=NA

df$response2=NA
df$SD2=NA
df$n2=NA

# Response ratios and number of samples.
### Before-After
df$response1[df$Study.type == "Before After"] = df$Mean_Before_impact[df$Study.type == "Before After"]
df$n1[df$Study.type == "Before After"]        = df$n_Before_impact[df$Study.type == "Before After"]

### Control-Impact
df$response2[df$Study.type == "Before After"] = df$Mean_After_impact[df$Study.type == "Before After"]
df$n2[df$Study.type == "Before After"]        = df$n_After_impact[df$Study.type == "Before After"]

### BACI
df$response1[df$Study.type == "Control Impact"] = df$Mean_After_control[df$Study.type == "Control Impact"]
df$response2[df$Study.type == "Control Impact"] = df$Mean_After_impact[df$Study.type == "Control Impact"]
df$n1[df$Study.type == "Control Impact"]        = df$n_After_control[df$Study.type == "Control Impact"]
df$n2[df$Study.type == "Control Impact"]        = df$n_After_impact[df$Study.type == "Control Impact"]

df$AftCtrl_BefCtrl = df$Mean_After_control/df$Mean_Before_control
df$AftImpt_BefImpt = df$Mean_After_impact/df$Mean_Before_impact
df$response1[df$Study.type == "Before After Control Impact"] = df$AftCtrl_BefCtrl[df$Study.type == "Before After Control Impact"]
df$response2[df$Study.type == "Before After Control Impact"] = df$AftImpt_BefImpt[df$Study.type == "Before After Control Impact"]

df$n1[df$Study.type == "Before After Control Impact"]        = (df$n_After_control[df$Study.type == "Before After Control Impact"] 
                                                           + df$n_Before_control[df$Study.type == "Before After Control Impact"])/2
df$n2[df$Study.type == "Before After Control Impact"]        = (df$n_After_impact[df$Study.type == "Before After Control Impact"] 
                                                           + df$n_Before_impact[df$Study.type == "Before After Control Impact"])/2

# Standard deviations.
### Before After
df$SD1[df$Study.type == "Before After"]       = df$SD_Before_impact[df$Study.type == "Before After"]

### Control-Impact
df$SD2[df$Study.type == "Before After"]       = df$SD_After_impact[df$Study.type == "Before After"]

### BACI
df$SD1[df$Study.type == "Control Impact"]       = df$SD_After_control[df$Study.type == "Control Impact"]
df$SD2[df$Study.type == "Control Impact"]       = df$SD_After_impact[df$Study.type == "Control Impact"]

#### Before After Control Impact studies
df$SD1[df$Study.type == "Before After Control Impact"] = df$SD_After_control[df$Study.type == "Before After Control Impact"]
df$SD2[df$Study.type == "Before After Control Impact"] = df$SD_After_impact[df$Study.type == "Before After Control Impact"]

newdf <- df

## Remove inherent NA's due to missing response 1 or response 2
toremove <- unique(c(which(is.na(newdf$response1)), which(is.na(newdf$response2)))) # length = 53
newdf$note <- "OK"
newdf$note[toremove] <- "NO MATCHING PAIR"
rm(toremove)

newdf$noteresp1 <- "OK"
newdf$noteresp2 <- "OK"

```

## Adding missing SD

This part imputes standard deviations where possible and adds labels of which action has been performed.

```{r label, options}
#### Adding in missing SD's.
## Fill in sd function.
# make a not in function for later by negating %in%. !%in% does not work.

`%notin%` <- Negate(`%in%`) 

# Function is missSD and requires columns of the specific treatment to be filled in.
# I don't think i can use all treatments together to calculate missing sd.
## Debugging
# dff = newdf
# mean = "response1"
# sd = "SD1"
# nc = "n1"
# notes = "note"
#  i <- "bacterial C production"
# notesspec <- "noteresp1"
# re <- "response1"

inflist <- NULL

missingSD <- function(dff, mean, sd, nc, notes, notesspec, re, infolist){
  
  for (i in unique(dff[["Response.variable"]])){
    
    subset <- dff[dff["Response.variable"] == i,] # Select subset of variable i
    tofill <- which(is.na(subset[,sd]) & subset[notes] == "OK")  # which rows with SD's need to be filled?
    filled <- which(!is.na(subset[,sd]) & subset[notes] == "OK") # which rows are filled.
    
    infolist[[i]][[re]][["ntotinitial"]] <- sum(length(tofill), length(filled))
    infolist[[i]][[re]][["sdstatus"]] <- paste0(length(tofill), " missing SD, ", length(filled), " present SD")
    
    # If there are more sd's to be estimated than known sd's, they should all be removed.
    if(length(tofill) > length(filled)){
      
      dff[notesspec][as.numeric(rownames(subset))[tofill],] <- "More missing SD than known SD remove all"
      infolist[[i]][[re]][["sdfillstatus"]] <- "More missing SD than known SD remove all"
        
    # If all sd's should be estimated, they should all be removed.
    }else if (length(tofill) == length(subset[,sd])){
      
     dff[notesspec][as.numeric(rownames(subset))[tofill],] <- "All SD missing remove all"
     infolist[[i]][[re]][["sdfillstatus"]] <- "All SD missing remove all"
     
    # If no sd's need to be filled, do nothing.
    }else if (length(tofill) == 0){
      
      dff[notesspec][as.numeric(rownames(subset))[tofill],] <- "OK"
      infolist[[i]][[re]][["sdfillstatus"]] <- "All SD present no action needed"   
      
    # If some need to be filled, it depends whether n is 1 or n > 1.
    }else{
      
      infolist[[i]][[re]][["sdfillstatus"]] <- "Some need to be filled"   

      n1counter <- 0
      nncounter <- 0
      
      for(j in tofill){
        
        dff$sdadded[as.numeric(rownames(subset)[j])] <- 1
          
        if(subset[j,nc] == 1){             # If n = 1 then the sd is just 0.
          
          n1counter <- n1counter + 1
          subset[j, sd] <- max(subset[sd], na.rm = TRUE)
          subset[j, notesspec] <- "n = 1 so max SD added"
          
        } else{
          
          nncounter <- nncounter + 1
          
          # summed means -> sum all means of which an sd is known in subset.
          smean <- sum(na.omit(subset[subset[notes] == "OK", mean][-tofill]))
          
          # summed sd -> sum all known sds in subset.
          ssd   <- sum(na.omit(subset[subset[notes] == "OK", sd][-tofill]))
          
          # Calc the new sd with formula from book and replace sd.
          newsd     <- subset[j, mean] * ssd/smean
          subset[j, sd] <- abs(newsd)
          subset[j, notesspec] <- "averaged existing SD added"
        }     
      }
      
     infolist[[i]][[re]][["nis1"]] <- n1counter
     infolist[[i]][[re]][["nisn"]] <- nncounter
      
     dff[sd][as.numeric(rownames(subset)),] <- subset[[sd]]
     dff[notesspec][as.numeric(rownames(subset)),] <- subset[[notesspec]]
    }
  }
  return(list(dataframe = dff, info = infolist))
}

```

# Applying the function and saving the dataframe

```{r label, options}

newdf <- missingSD(dff = newdf, mean = 59, sd = 60, nc = 61, notes = 67, notesspec = 68, re = "response1", infolist = inflist)              # Response1
newdf <- missingSD(dff = newdf$dataframe, mean = 62, sd = 63, nc = 64, notes = 67, notesspec = 69, re = "response2", infolist = newdf$info) # Response2

# save
datframe <- newdf$dataframe 
save(datframe, file = "../dataset/dataset.rdata")

```

# Overview of what was added/changed

```{r}

knitr::kable(table(datframe$Response.variable, datframe$noteresp1 ))
knitr::kable(table(datframe$Response.variable, datframe$noteresp2 ))

```




